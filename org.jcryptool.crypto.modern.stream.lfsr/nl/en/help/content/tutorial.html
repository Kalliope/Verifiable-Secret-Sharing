<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>

<body>
	<h1>LFSR</h1>

	<h2>What is an LFSR?</h2>

	<p>A linear feedback shift register (LFSR) is a sequential shift register with combinational logic
	which causes it to pseudo-randomly cycle through a sequence of binary values. The only
	linear functions of single bits are xor and inverse-xor; thus it is a shift register whose input
	bit is driven by the exclusive-or (xor) of some bits of the overall shift register value.
	The initial value of the LFSR is called the seed, and because the operation of the register
	is deterministic, the sequence of values produced by the register is completely determined
	by its current (or previous) state. Likewise, because the register has a finite number of
	possible states, it must eventually enter a repeating cycle. However, an LFSR with a well chosen
	feedback function can produce a sequence of bits which appears random and
	which has a very long cycle. A design modeled after LFSRs often has both speed and
	area advantages over a functionally equivalent design that does not use LFSRs.</p>

	<h2>How do LFSRs work?</h2>

	<p>Linear feedback shift registers can be implemented in more than one way, but the scope of
	this document will focus on the most common - the Fibonacci implementation. The
	Fibonacci implementation consists of a simple shift register in which the list of the bits'
	positions that affect the next state is called the tap sequence. In the diagram below, the
	sequence is [16,14,13,11,0]. The taps are XOR'd sequentially with the output and then fed
	back into the leftmost bit.<br>
	The outputs that influence the input are called taps (white in the diagram). A maximal
	LFSR produces an m-sequence (i.e. cycles through all possible 2n-1 states within the shift
	register except the state where all bits are zero), unless it contains all zeros, in which case
	it will never change.<br>
	The sequence of numbers generated by an LFSR can be considered a binary numeral
	system, while the tap sequence of an LFSR can be represented as a polynomial mod 2.
	This means that the coefficients of the polynomial must be 1's or 0's. This is called the
	feedback polynomial or characteristic polynomial. For example, if the taps are at the 16th,
	14th, 13th and 11th bits (as shown), the feedback polynomial is:</p>

	<img src="figure1.png">

	<p>The 'one' in the polynomial does not correspond to a tap - it corresponds to the input to the
	first bit (i.e. x0, which is equivalent to 1). The powers of the terms represent the tapped
	bits, counting from the left. The first and last bits are always connected as an input and tap
	respectively.</p>

	<img src="figure2.png"><br>
	Figure 1: Fibonacci LFSR Diagram<br><br>

	<h3>LFSR Properties</h3>

	<ul>
		<li>The LFSR will only be maximal if the number of taps is even; just 2 or 4 taps can suffice even for extremely long sequences.</li>
		<li>The set of taps must be relatively prime, and share no common divisor to all taps.</li>
		<li>There can be more than one maximal tap sequence for a given LFSR length.</li>
	</ul>

	<h3>Output Stream Properties</h3>

	<ul>
		<li>Ones and zeroes occur in 'runs'. The output stream 0110100, for example consists of five runs of lengths 1,2,1,1,2, in order. In one period of a maximal LFSR, 2n-1 runs occur (for example, a six bit LFSR will have 32 runs). Exactly 1/2 of these runs will be one bit long, 1/4 will be two bits long, up to a single run of zeroes n-1 bits long, and a single run of ones n bits long. This same property is statistically expected in a truly random sequence.</li>
		<li>LFSR output streams are deterministic. If you know the present state, you can predict the next state. This is not possible with truly random events such as nuclear decay.</li>
		<li>The output stream is reversible; an LFSR with mirrored tap sequence will cycle through the states in reverse order.</li>
	</ul>

	<h3>Maximal Length Tap Sequences</h3>

	<p>The choice of which taps to use determines how many values are included in a sequence
	of pseudo-random values before the sequence is repeated. Certain tap settings yield the
	maximal length sequences of (2N-1).<br>
	The length of an LFSR sequence before repetition occurs depends upon two things, the
	feedback taps and the initial state. An LFSR of any given size m (number of registers) is
	capable of producing every possible state during the period N=2m-1, but will do so only if
	proper feedback taps, or terms, have been chosen. Such a sequence is called a maximal
	length sequence (m-sequence). In cryptography, m-sequences are referred to as a
	pseudonoise (PN) or pseudorandom sequences, due to their optimal noise-like
	characteristics.<br>
	When the feedback taps of an LFSR are non-maximal, the length of the generated
	sequence depends upon the initial state of the LFSR. A non-maximal generator is capable
	of producing two or more unique sequences (plus the trivial all-zeros one), with the initial
	state determining which is produced. Each of these sequences is referred to as a state
	space of the generator. Together, all possible non-maximal sequences account for all 2m
	states of an m-bit state register.<br>
	Properties of non-maximal sequences are generally inferior to those of maximal
	sequences. So the use of non-maximal sequences in real systems is usually avoided in
	favor of their maximal-length counterparts.</p>

	<h2>Why are LFSRs useful?</h2>

	<p>LFSRs have long been used as pseudo-random number generators for use in stream
	ciphers (especially in military cryptography), due to the ease of construction from simple
	electromechanical or electronic circuits, long periods, and very uniformly distributed
	outputs. However, an LFSR is a linear system, leading to fairly easy cryptanalysis. For
	example, given a stretch of known plaintext and corresponding ciphertext, a stretch of
	LFSR output used in the system described above can be recovered, and from the output
	sequence one can construct an LFSR of minimal size by using the Berlekamp-Massey
	algorithm, which with the known output can be used to simulate the intended receiver to
	recover the remaining plaintext.<br>
	Important LFSR-based stream ciphers include A5/1 and A5/2, used in GSM cell phones,
	E0, used in Bluetooth, and the shrinking generator. The A5/2 cipher has been broken and
	both A5/1 and E0 have serious weaknesses.</p>

	<h2>Where can I go to find out more?</h2>

	<ul>
		<li><a href="http://www.maxim-ic.com/appnotes.cfm?appnote_number=1743&CMP=WP-9">Pseudo-Random Number Generation Routine</a></li>
		<li><a href="http://www.yikes.com/~ptolemy/lfsr_web/index.htm">Simple explanation of LFSRs for Engineers</a></li>
		<li><a href="http://homepage.mac.com/afj/lfsr.html">General LFSR Theory</a></li>
	</ul>
</body>
</html>
